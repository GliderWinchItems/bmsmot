ARM GAS  /tmp/ccDiUcPk.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.syntax unified
  17              		.file	"SerialTaskSend.c"
  18              		.text
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.section	.text.StartSerialTaskSend,"ax",%progbits
  22              		.align	2
  23              		.global	StartSerialTaskSend
  24              		.thumb
  25              		.thumb_func
  27              	StartSerialTaskSend:
  28              	.LFB293:
  29              		.file 1 "Ourwares/SerialTaskSend.c"
   1:Ourwares/SerialTaskSend.c **** /******************************************************************************
   2:Ourwares/SerialTaskSend.c **** * File Name          : SerialTaskSend.c
   3:Ourwares/SerialTaskSend.c **** * Date First Issued  : 12/09/2018
   4:Ourwares/SerialTaskSend.c **** * Description        : Multiple task serial output using FreeRTOS/ST HAL
   5:Ourwares/SerialTaskSend.c **** *******************************************************************************/
   6:Ourwares/SerialTaskSend.c **** 
   7:Ourwares/SerialTaskSend.c **** #include "FreeRTOS.h"
   8:Ourwares/SerialTaskSend.c **** #include "task.h"
   9:Ourwares/SerialTaskSend.c **** #include "queue.h"
  10:Ourwares/SerialTaskSend.c **** #include "cmsis_os.h"
  11:Ourwares/SerialTaskSend.c **** #include "malloc.h"
  12:Ourwares/SerialTaskSend.c **** 
  13:Ourwares/SerialTaskSend.c **** #include "SerialTaskSend.h"
  14:Ourwares/SerialTaskSend.c **** #include "morse.h"
  15:Ourwares/SerialTaskSend.c **** 
  16:Ourwares/SerialTaskSend.c **** /*
  17:Ourwares/SerialTaskSend.c **** Goals: 
  18:Ourwares/SerialTaskSend.c **** - Use the HAl driver unmodified
  19:Ourwares/SerialTaskSend.c ****   .  Issue: the interrupt callback callback is common
  20:Ourwares/SerialTaskSend.c ****      to all uarts and carries a uart control block
  21:Ourwares/SerialTaskSend.c ****      pointer as an argument.
  22:Ourwares/SerialTaskSend.c **** 
  23:Ourwares/SerialTaskSend.c **** - (Maybe!) use same scheme with usb CDC.  Maybe same code?
  24:Ourwares/SerialTaskSend.c **** 
  25:Ourwares/SerialTaskSend.c **** - Handle 'n' uart/usarts 
  26:Ourwares/SerialTaskSend.c ****   .  So far, three have been used, so allowing for six
  27:Ourwares/SerialTaskSend.c ****      (stm32F407) may be overkill, but later stm32 versions
  28:Ourwares/SerialTaskSend.c ****      may allow even more.
  29:Ourwares/SerialTaskSend.c **** 
ARM GAS  /tmp/ccDiUcPk.s 			page 2


  30:Ourwares/SerialTaskSend.c **** - FreeRTOS can output serial data from multiple tasks
  31:Ourwares/SerialTaskSend.c **** 
  32:Ourwares/SerialTaskSend.c **** - Buffering:
  33:Ourwares/SerialTaskSend.c ****   .  Not depend on time before reusing a buffer, therefore
  34:Ourwares/SerialTaskSend.c ****      interrupts need to drive it.
  35:Ourwares/SerialTaskSend.c ****   .  Use a circular buffer that holds pointers
  36:Ourwares/SerialTaskSend.c ****      and handles to the originating task & task buffer.
  37:Ourwares/SerialTaskSend.c ****      .. copying char-by-char wasteful so use pointer control block
  38:Ourwares/SerialTaskSend.c ****      .. Multiple buffers for multiple uarts
  39:Ourwares/SerialTaskSend.c ****   .  Use source task's buffer and notify source task
  40:Ourwares/SerialTaskSend.c ****      when the buffer has been sent, using
  41:Ourwares/SerialTaskSend.c ****        'xTaskNotifyFromISR'
  42:Ourwares/SerialTaskSend.c **** 
  43:Ourwares/SerialTaskSend.c **** Scheme:
  44:Ourwares/SerialTaskSend.c **** 
  45:Ourwares/SerialTaskSend.c **** - Initialization:
  46:Ourwares/SerialTaskSend.c ****   .  Create, or add, to a linked list with pointer to next
  47:Ourwares/SerialTaskSend.c ****      block, uart/usart handle, and pointers to a circular
  48:Ourwares/SerialTaskSend.c ****      buffer calloc'ed for the number of task buffers to be used.
  49:Ourwares/SerialTaskSend.c ****      This done for each uart/usart implemented.
  50:Ourwares/SerialTaskSend.c **** 
  51:Ourwares/SerialTaskSend.c **** - Usage:
  52:Ourwares/SerialTaskSend.c ****   .  A task generates the bytes to be sent in a buffer.
  53:Ourwares/SerialTaskSend.c ****   .  A buffer control block is initialized with the 
  54:Ourwares/SerialTaskSend.c ****      task handle, uart/usart handle, buffer pointer, and
  55:Ourwares/SerialTaskSend.c ****      number of bytes to be sent (size).  (All but the size 
  56:Ourwares/SerialTaskSend.c ****      can be initialized before the task endless loop begins.)
  57:Ourwares/SerialTaskSend.c ****   .  The buffer control block (bcb) is sent to this routine's queue.
  58:Ourwares/SerialTaskSend.c ****      This routine removes the bcb from the queue and adds it
  59:Ourwares/SerialTaskSend.c ****      to the circular buffer for the uart/usart, then attempts
  60:Ourwares/SerialTaskSend.c ****      to send it with the HAL routine.  The HAL routine rejects
  61:Ourwares/SerialTaskSend.c ****      the attempt if it is already busy.
  62:Ourwares/SerialTaskSend.c ****   .  Upon interrupt, the interrupt callback routine checks 
  63:Ourwares/SerialTaskSend.c ****      the circular buffer for the uart/usart causing the completion
  64:Ourwares/SerialTaskSend.c ****      of the sending interrupt.  
  65:Ourwares/SerialTaskSend.c ****      .. It issues a "notification" to the task identified in the
  66:Ourwares/SerialTaskSend.c ****         circular buffer block, so that the originating task can
  67:Ourwares/SerialTaskSend.c ****         reuse the buffer.
  68:Ourwares/SerialTaskSend.c ****      .. It "removes" (moves the pointer) the bcb from the circular
  69:Ourwares/SerialTaskSend.c ****         buffer.  If more bcb's are in the circular buffer, it
  70:Ourwares/SerialTaskSend.c ****         starts the HAL routine with the next bcb.
  71:Ourwares/SerialTaskSend.c ****            
  72:Ourwares/SerialTaskSend.c **** Note: If a uart/usart is not called from multiple tasks, i.e.
  73:Ourwares/SerialTaskSend.c ****      just one task uses the usart/usart, and there is no need
  74:Ourwares/SerialTaskSend.c ****      to overlap processing in that task with more than one
  75:Ourwares/SerialTaskSend.c ****      output buffer, then this routine does not need to be used.
  76:Ourwares/SerialTaskSend.c **** 
  77:Ourwares/SerialTaskSend.c **** Multiple tasks can place "struct SERIALSENDTASKBCB" items (BCB) in a queue. 
  78:Ourwares/SerialTaskSend.c **** The BCB holds:
  79:Ourwares/SerialTaskSend.c ****  - Originating task handle
  80:Ourwares/SerialTaskSend.c ****  - uart/usart control block pointer
  81:Ourwares/SerialTaskSend.c ****  - buffer pointer
  82:Ourwares/SerialTaskSend.c ****  - buffer size
  83:Ourwares/SerialTaskSend.c ****  - uart|usart flag
  84:Ourwares/SerialTaskSend.c ****  - bits for notifying originating task when the buffer has been sent, (so
  85:Ourwares/SerialTaskSend.c ****      that the originating task can reuse the buffer).
  86:Ourwares/SerialTaskSend.c **** 
ARM GAS  /tmp/ccDiUcPk.s 			page 3


  87:Ourwares/SerialTaskSend.c **** A circular buffer of BCBs is created for each uart/usart.  The size of this
  88:Ourwares/SerialTaskSend.c **** circular buffer must be at least as large as the number of buffers of
  89:Ourwares/SerialTaskSend.c **** the tasks using this routine.
  90:Ourwares/SerialTaskSend.c **** 
  91:Ourwares/SerialTaskSend.c **** 
  92:Ourwares/SerialTaskSend.c **** 
  93:Ourwares/SerialTaskSend.c **** */
  94:Ourwares/SerialTaskSend.c **** 
  95:Ourwares/SerialTaskSend.c **** 
  96:Ourwares/SerialTaskSend.c **** /* Task */
  97:Ourwares/SerialTaskSend.c **** #define SSPRIORITY 1	// Priority for this task (0 = Normal, -3 = Idle)
  98:Ourwares/SerialTaskSend.c **** 
  99:Ourwares/SerialTaskSend.c **** //static uint32_t SerialTaskSendBuffer[ 64 ];
 100:Ourwares/SerialTaskSend.c **** 
 101:Ourwares/SerialTaskSend.c **** //static osStaticThreadDef_t SerialTaskSendControlBlock;
 102:Ourwares/SerialTaskSend.c **** 
 103:Ourwares/SerialTaskSend.c **** osThreadId SerialTaskHandle = NULL;
 104:Ourwares/SerialTaskSend.c **** 
 105:Ourwares/SerialTaskSend.c **** 
 106:Ourwares/SerialTaskSend.c **** /* Queue */
 107:Ourwares/SerialTaskSend.c **** #define QUEUESIZE 16	// Total size of bcb's tasks can queue up
 108:Ourwares/SerialTaskSend.c **** 
 109:Ourwares/SerialTaskSend.c **** osMessageQId SerialTaskSendQHandle;
 110:Ourwares/SerialTaskSend.c **** //static uint8_t SerialTaskSendQBuffer[ QUEUESIZE * sizeof( struct SERIALSENDTASKBCB ) ];
 111:Ourwares/SerialTaskSend.c **** //static osStaticMessageQDef_t SerialTaskSendQCB;
 112:Ourwares/SerialTaskSend.c **** 
 113:Ourwares/SerialTaskSend.c **** /* Pattern
 114:Ourwares/SerialTaskSend.c **** osMessageQId testQueue01Handle;
 115:Ourwares/SerialTaskSend.c **** uint8_t myQueue01Buffer[ 16 * sizeof( uint16_t ) ];
 116:Ourwares/SerialTaskSend.c **** osStaticMessageQDef_t myQueue01ControlBlock;
 117:Ourwares/SerialTaskSend.c **** */
 118:Ourwares/SerialTaskSend.c **** 
 119:Ourwares/SerialTaskSend.c **** /* Serial Send Cir Buf: Block with pointers into the circular buffer of pointers. */
 120:Ourwares/SerialTaskSend.c **** struct SSCIRBUF
 121:Ourwares/SerialTaskSend.c **** {
 122:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* pnext;
 123:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB** pbegin;
 124:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB** pend;
 125:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB** padd;
 126:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB** ptake;
 127:Ourwares/SerialTaskSend.c **** 	UART_HandleTypeDef* phuart;
 128:Ourwares/SerialTaskSend.c **** 	int8_t	dmaflag;           // 0 = char-by-char; 1 = dma
 129:Ourwares/SerialTaskSend.c **** };
 130:Ourwares/SerialTaskSend.c **** 
 131:Ourwares/SerialTaskSend.c **** /* Points to first of list of struct SSCIRBUF */
 132:Ourwares/SerialTaskSend.c **** struct SSCIRBUF* pbhd = NULL;
 133:Ourwares/SerialTaskSend.c **** 
 134:Ourwares/SerialTaskSend.c **** 
 135:Ourwares/SerialTaskSend.c **** /* *************************************************************************
 136:Ourwares/SerialTaskSend.c ****  * BaseType_t xSerialTaskSendAdd(UART_HandleTypeDef* p, uint16_t qsize, int8_t dmaflag);
 137:Ourwares/SerialTaskSend.c ****  *	@brief	: Add a uart and circular buffer to a linked list
 138:Ourwares/SerialTaskSend.c ****  * @param	: p = pointer to uart control block
 139:Ourwares/SerialTaskSend.c ****  * @param	: qsize = total number of buffer control blocks circular buffer can hold
 140:Ourwares/SerialTaskSend.c ****  * @param	: dmaflag = 0 = char-by-char, 1 = dma
 141:Ourwares/SerialTaskSend.c ****  * @return	: 0 = OK, -1 = failed 1st calloc, -2 = failed 2nd calloc
 142:Ourwares/SerialTaskSend.c ****  * *************************************************************************/
 143:Ourwares/SerialTaskSend.c **** BaseType_t xSerialTaskSendAdd(UART_HandleTypeDef* p, uint16_t qsize, int8_t dmaflag)
ARM GAS  /tmp/ccDiUcPk.s 			page 4


 144:Ourwares/SerialTaskSend.c **** {
 145:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* ptmp1;
 146:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* ptmp2;
 147:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB** pssb;
 148:Ourwares/SerialTaskSend.c **** 
 149:Ourwares/SerialTaskSend.c **** taskENTER_CRITICAL();
 150:Ourwares/SerialTaskSend.c **** 	/* Add block with circular buffer pointers for this uart/usart to list */
 151:Ourwares/SerialTaskSend.c **** 	ptmp1 = (struct SSCIRBUF*)calloc(1, sizeof(struct SSCIRBUF));
 152:Ourwares/SerialTaskSend.c **** 	if (ptmp1 == NULL) {taskEXIT_CRITICAL();return -1;}
 153:Ourwares/SerialTaskSend.c **** 	if (pbhd  == NULL) // Is this the first?
 154:Ourwares/SerialTaskSend.c **** 	{ // Yes
 155:Ourwares/SerialTaskSend.c **** 		pbhd = ptmp1;	// Point head to first on list
 156:Ourwares/SerialTaskSend.c **** 		ptmp1->pnext = ptmp1; // Point first item on list to self
 157:Ourwares/SerialTaskSend.c **** 	}
 158:Ourwares/SerialTaskSend.c **** 	else
 159:Ourwares/SerialTaskSend.c **** 	{ // No, one or more have been added
 160:Ourwares/SerialTaskSend.c **** 		/* Find end of list */
 161:Ourwares/SerialTaskSend.c **** 		ptmp2 = pbhd;	// Start at head
 162:Ourwares/SerialTaskSend.c **** 		while (ptmp2 != ptmp2->pnext) ptmp2 = ptmp2->pnext;
 163:Ourwares/SerialTaskSend.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 164:Ourwares/SerialTaskSend.c **** 		ptmp1->pnext = ptmp1; // Added block points to self
 165:Ourwares/SerialTaskSend.c **** 	}
 166:Ourwares/SerialTaskSend.c **** 
 167:Ourwares/SerialTaskSend.c **** 	/* Get memory for circular buffer of buffer control blocks (bcb) */	
 168:Ourwares/SerialTaskSend.c **** 	pssb = (struct SERIALSENDTASKBCB**)calloc(qsize, sizeof(struct SERIALSENDTASKBCB*));
 169:Ourwares/SerialTaskSend.c **** 	if ( pssb == NULL) {taskEXIT_CRITICAL();return -2;}
 170:Ourwares/SerialTaskSend.c **** 
 171:Ourwares/SerialTaskSend.c **** 	/* Initialize pointers for circular buffer */
 172:Ourwares/SerialTaskSend.c **** 	// ptmp1 points to last item on list
 173:Ourwares/SerialTaskSend.c **** 	ptmp1->pbegin  = pssb;
 174:Ourwares/SerialTaskSend.c **** 	ptmp1->padd    = pssb;
 175:Ourwares/SerialTaskSend.c **** 	ptmp1->ptake   = pssb;
 176:Ourwares/SerialTaskSend.c **** 	ptmp1->pend    = pssb + qsize;
 177:Ourwares/SerialTaskSend.c **** 	ptmp1->phuart  = p;
 178:Ourwares/SerialTaskSend.c **** 	ptmp1->dmaflag = dmaflag;
 179:Ourwares/SerialTaskSend.c **** taskEXIT_CRITICAL();
 180:Ourwares/SerialTaskSend.c **** 	return 0;
 181:Ourwares/SerialTaskSend.c **** }
 182:Ourwares/SerialTaskSend.c **** 
 183:Ourwares/SerialTaskSend.c **** /* *************************************************************************
 184:Ourwares/SerialTaskSend.c ****  * void StartSerialTaskSend(void const * argument);
 185:Ourwares/SerialTaskSend.c ****  *	@brief	: Task startup
 186:Ourwares/SerialTaskSend.c ****  * *************************************************************************/
 187:Ourwares/SerialTaskSend.c **** void StartSerialTaskSend(void* argument1)
 188:Ourwares/SerialTaskSend.c **** {
  30              		.loc 1 188 0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 8
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              	.LVL0:
  35 0000 00B5     		push	{lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 4
  38              		.cfi_offset 14, -4
  39 0002 83B0     		sub	sp, sp, #12
  40              	.LCFI1:
  41              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccDiUcPk.s 			page 5


  42              	.LVL1:
  43              	.L2:
 189:Ourwares/SerialTaskSend.c **** 	BaseType_t Qret;	// queue receive return
 190:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB*  pssb; // Copied item from queue
 191:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* ptmp;	// Circular buffer pointer block pointer
 192:Ourwares/SerialTaskSend.c **** 
 193:Ourwares/SerialTaskSend.c ****   /* Infinite loop */
 194:Ourwares/SerialTaskSend.c ****   for(;;)
 195:Ourwares/SerialTaskSend.c ****   {
 196:Ourwares/SerialTaskSend.c **** 		do
 197:Ourwares/SerialTaskSend.c **** 		{
 198:Ourwares/SerialTaskSend.c **** 		/* Wait indefinitely for someone to load something into the queue */
 199:Ourwares/SerialTaskSend.c **** 		/* Skip over empty returns, and NULL pointers that would cause trouble */
 200:Ourwares/SerialTaskSend.c **** 			Qret = xQueueReceive(SerialTaskSendQHandle,&pssb,portMAX_DELAY);
  44              		.loc 1 200 0
  45 0004 4FF0FF32 		mov	r2, #-1
  46 0008 01A9     		add	r1, sp, #4
  47 000a 1E4B     		ldr	r3, .L12
  48 000c 1868     		ldr	r0, [r3]
  49 000e FFF7FEFF 		bl	xQueueReceive
  50              	.LVL2:
 201:Ourwares/SerialTaskSend.c **** 			if (Qret == pdPASS) // Break loop if not empty
  51              		.loc 1 201 0
  52 0012 0128     		cmp	r0, #1
  53 0014 06D0     		beq	.L3
 202:Ourwares/SerialTaskSend.c **** 				break;
 203:Ourwares/SerialTaskSend.c **** 		} while ((pssb->phuart == NULL) || (pssb->tskhandle == NULL));
  54              		.loc 1 203 0
  55 0016 019B     		ldr	r3, [sp, #4]
  56 0018 1A68     		ldr	r2, [r3]
  57 001a 002A     		cmp	r2, #0
  58 001c F2D0     		beq	.L2
  59              		.loc 1 203 0 is_stmt 0 discriminator 1
  60 001e 5B68     		ldr	r3, [r3, #4]
  61 0020 002B     		cmp	r3, #0
  62 0022 EFD0     		beq	.L2
  63              	.L3:
 204:Ourwares/SerialTaskSend.c **** 
 205:Ourwares/SerialTaskSend.c **** 		/* Add Q item to linked list for this uart/usart */
 206:Ourwares/SerialTaskSend.c **** 
 207:Ourwares/SerialTaskSend.c **** 		/* Find uart/usart list for this item from Q */
 208:Ourwares/SerialTaskSend.c **** 		ptmp = pbhd;
  64              		.loc 1 208 0 is_stmt 1
  65 0024 184B     		ldr	r3, .L12+4
  66 0026 1B68     		ldr	r3, [r3]
  67              	.LVL3:
 209:Ourwares/SerialTaskSend.c **** 		while (ptmp->phuart != pssb->phuart) ptmp = ptmp->pnext;
  68              		.loc 1 209 0
  69 0028 00E0     		b	.L5
  70              	.LVL4:
  71              	.L6:
  72              		.loc 1 209 0 is_stmt 0 discriminator 2
  73 002a 1B68     		ldr	r3, [r3]
  74              	.LVL5:
  75              	.L5:
  76              		.loc 1 209 0 discriminator 1
  77 002c 5969     		ldr	r1, [r3, #20]
ARM GAS  /tmp/ccDiUcPk.s 			page 6


  78 002e 0198     		ldr	r0, [sp, #4]
  79 0030 0268     		ldr	r2, [r0]
  80 0032 9142     		cmp	r1, r2
  81 0034 F9D1     		bne	.L6
 210:Ourwares/SerialTaskSend.c **** 
 211:Ourwares/SerialTaskSend.c **** 	 	if ((pssb->pbuf == NULL) || (pssb->size == 0))
  82              		.loc 1 211 0 is_stmt 1
  83 0036 C268     		ldr	r2, [r0, #12]
  84 0038 0AB1     		cbz	r2, .L7
  85              		.loc 1 211 0 is_stmt 0 discriminator 1
  86 003a 028A     		ldrh	r2, [r0, #16]
  87 003c 32B9     		cbnz	r2, .L8
  88              	.L7:
 212:Ourwares/SerialTaskSend.c **** 		{ // Here, HAL is going to reject it
 213:Ourwares/SerialTaskSend.c ****   			/* Release buffer just sent so it can be reused. */
 214:Ourwares/SerialTaskSend.c **** 			xSemaphoreGive(pssb->semaphore);
  89              		.loc 1 214 0 is_stmt 1
  90 003e 0023     		movs	r3, #0
  91              	.LVL6:
  92 0040 1A46     		mov	r2, r3
  93 0042 1946     		mov	r1, r3
  94 0044 8068     		ldr	r0, [r0, #8]
  95 0046 FFF7FEFF 		bl	xQueueGenericSend
  96              	.LVL7:
  97 004a DBE7     		b	.L2
  98              	.LVL8:
  99              	.L8:
 215:Ourwares/SerialTaskSend.c **** 		}
 216:Ourwares/SerialTaskSend.c **** 		else
 217:Ourwares/SerialTaskSend.c **** 		{
 218:Ourwares/SerialTaskSend.c **** 			/* Add bcb to circular buffer for this uart/usart */
 219:Ourwares/SerialTaskSend.c **** 			*ptmp->padd = pssb; //Copy BCB pointer into circular buffer
 100              		.loc 1 219 0
 101 004c DA68     		ldr	r2, [r3, #12]
 102 004e 1060     		str	r0, [r2]
 220:Ourwares/SerialTaskSend.c **** 
 221:Ourwares/SerialTaskSend.c **** 			ptmp->padd += 1;	// Advance list ptr with wraparound
 103              		.loc 1 221 0
 104 0050 DA68     		ldr	r2, [r3, #12]
 105 0052 0432     		adds	r2, r2, #4
 106 0054 DA60     		str	r2, [r3, #12]
 222:Ourwares/SerialTaskSend.c **** 			if (ptmp->padd == ptmp->pend) ptmp->padd = ptmp->pbegin;
 107              		.loc 1 222 0
 108 0056 9968     		ldr	r1, [r3, #8]
 109 0058 8A42     		cmp	r2, r1
 110 005a 01D1     		bne	.L9
 111              		.loc 1 222 0 is_stmt 0 discriminator 1
 112 005c 5A68     		ldr	r2, [r3, #4]
 113 005e DA60     		str	r2, [r3, #12]
 114              	.L9:
 223:Ourwares/SerialTaskSend.c **** 			{		
 224:Ourwares/SerialTaskSend.c ****    	   /* If HAL for this uart/usart is busy nothing happens. */
 225:Ourwares/SerialTaskSend.c **** 				if (ptmp->dmaflag == 0) // send buffer via char-by-char or dma 
 115              		.loc 1 225 0 is_stmt 1
 116 0060 93F91830 		ldrsb	r3, [r3, #24]
 117              	.LVL9:
 118 0064 33B9     		cbnz	r3, .L10
ARM GAS  /tmp/ccDiUcPk.s 			page 7


 226:Ourwares/SerialTaskSend.c **** 		 			HAL_UART_Transmit_IT((UART_HandleTypeDef*)pssb->phuart,pssb->pbuf,pssb->size);
 119              		.loc 1 226 0
 120 0066 019B     		ldr	r3, [sp, #4]
 121 0068 1A8A     		ldrh	r2, [r3, #16]
 122 006a D968     		ldr	r1, [r3, #12]
 123 006c 1868     		ldr	r0, [r3]
 124 006e FFF7FEFF 		bl	HAL_UART_Transmit_IT
 125              	.LVL10:
 126 0072 C7E7     		b	.L2
 127              	.L10:
 227:Ourwares/SerialTaskSend.c **** 				else		
 228:Ourwares/SerialTaskSend.c ****  					HAL_UART_Transmit_DMA((UART_HandleTypeDef*)pssb->phuart,pssb->pbuf,pssb->size);
 128              		.loc 1 228 0
 129 0074 019B     		ldr	r3, [sp, #4]
 130 0076 1A8A     		ldrh	r2, [r3, #16]
 131 0078 D968     		ldr	r1, [r3, #12]
 132 007a 1868     		ldr	r0, [r3]
 133 007c FFF7FEFF 		bl	HAL_UART_Transmit_DMA
 134              	.LVL11:
 135 0080 C0E7     		b	.L2
 136              	.L13:
 137 0082 00BF     		.align	2
 138              	.L12:
 139 0084 00000000 		.word	SerialTaskSendQHandle
 140 0088 00000000 		.word	.LANCHOR0
 141              		.cfi_endproc
 142              	.LFE293:
 144              		.section	.text.xSerialTaskSendAdd,"ax",%progbits
 145              		.align	2
 146              		.global	xSerialTaskSendAdd
 147              		.thumb
 148              		.thumb_func
 150              	xSerialTaskSendAdd:
 151              	.LFB292:
 144:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* ptmp1;
 152              		.loc 1 144 0
 153              		.cfi_startproc
 154              		@ args = 0, pretend = 0, frame = 0
 155              		@ frame_needed = 0, uses_anonymous_args = 0
 156              	.LVL12:
 157 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 158              	.LCFI2:
 159              		.cfi_def_cfa_offset 24
 160              		.cfi_offset 3, -24
 161              		.cfi_offset 4, -20
 162              		.cfi_offset 5, -16
 163              		.cfi_offset 6, -12
 164              		.cfi_offset 7, -8
 165              		.cfi_offset 14, -4
 166 0002 0746     		mov	r7, r0
 167 0004 0D46     		mov	r5, r1
 168 0006 1646     		mov	r6, r2
 149:Ourwares/SerialTaskSend.c **** 	/* Add block with circular buffer pointers for this uart/usart to list */
 169              		.loc 1 149 0
 170 0008 FFF7FEFF 		bl	vPortEnterCritical
 171              	.LVL13:
 151:Ourwares/SerialTaskSend.c **** 	if (ptmp1 == NULL) {taskEXIT_CRITICAL();return -1;}
ARM GAS  /tmp/ccDiUcPk.s 			page 8


 172              		.loc 1 151 0
 173 000c 1C21     		movs	r1, #28
 174 000e 0120     		movs	r0, #1
 175 0010 FFF7FEFF 		bl	calloc
 176              	.LVL14:
 152:Ourwares/SerialTaskSend.c **** 	if (pbhd  == NULL) // Is this the first?
 177              		.loc 1 152 0
 178 0014 20B9     		cbnz	r0, .L15
 152:Ourwares/SerialTaskSend.c **** 	if (pbhd  == NULL) // Is this the first?
 179              		.loc 1 152 0 is_stmt 0 discriminator 1
 180 0016 FFF7FEFF 		bl	vPortExitCritical
 181              	.LVL15:
 182 001a 4FF0FF30 		mov	r0, #-1
 183 001e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 184              	.LVL16:
 185              	.L15:
 186 0020 0446     		mov	r4, r0
 153:Ourwares/SerialTaskSend.c **** 	{ // Yes
 187              		.loc 1 153 0 is_stmt 1
 188 0022 114B     		ldr	r3, .L22
 189 0024 1B68     		ldr	r3, [r3]
 190 0026 23B9     		cbnz	r3, .L17
 155:Ourwares/SerialTaskSend.c **** 		ptmp1->pnext = ptmp1; // Point first item on list to self
 191              		.loc 1 155 0
 192 0028 0F4B     		ldr	r3, .L22
 193 002a 1860     		str	r0, [r3]
 156:Ourwares/SerialTaskSend.c **** 	}
 194              		.loc 1 156 0
 195 002c 2060     		str	r0, [r4]
 196 002e 05E0     		b	.L18
 197              	.LVL17:
 198              	.L20:
 162:Ourwares/SerialTaskSend.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 199              		.loc 1 162 0
 200 0030 1346     		mov	r3, r2
 201              	.LVL18:
 202              	.L17:
 162:Ourwares/SerialTaskSend.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 203              		.loc 1 162 0 is_stmt 0 discriminator 1
 204 0032 1A68     		ldr	r2, [r3]
 205 0034 9342     		cmp	r3, r2
 206 0036 FBD1     		bne	.L20
 163:Ourwares/SerialTaskSend.c **** 		ptmp1->pnext = ptmp1; // Added block points to self
 207              		.loc 1 163 0 is_stmt 1
 208 0038 1C60     		str	r4, [r3]
 164:Ourwares/SerialTaskSend.c **** 	}
 209              		.loc 1 164 0
 210 003a 2460     		str	r4, [r4]
 211              	.LVL19:
 212              	.L18:
 168:Ourwares/SerialTaskSend.c **** 	if ( pssb == NULL) {taskEXIT_CRITICAL();return -2;}
 213              		.loc 1 168 0
 214 003c 0421     		movs	r1, #4
 215 003e 2846     		mov	r0, r5
 216              	.LVL20:
 217 0040 FFF7FEFF 		bl	calloc
 218              	.LVL21:
ARM GAS  /tmp/ccDiUcPk.s 			page 9


 169:Ourwares/SerialTaskSend.c **** 
 219              		.loc 1 169 0
 220 0044 20B9     		cbnz	r0, .L19
 169:Ourwares/SerialTaskSend.c **** 
 221              		.loc 1 169 0 is_stmt 0 discriminator 1
 222 0046 FFF7FEFF 		bl	vPortExitCritical
 223              	.LVL22:
 224 004a 6FF00100 		mvn	r0, #1
 225 004e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 226              	.LVL23:
 227              	.L19:
 173:Ourwares/SerialTaskSend.c **** 	ptmp1->padd    = pssb;
 228              		.loc 1 173 0 is_stmt 1
 229 0050 6060     		str	r0, [r4, #4]
 174:Ourwares/SerialTaskSend.c **** 	ptmp1->ptake   = pssb;
 230              		.loc 1 174 0
 231 0052 E060     		str	r0, [r4, #12]
 175:Ourwares/SerialTaskSend.c **** 	ptmp1->pend    = pssb + qsize;
 232              		.loc 1 175 0
 233 0054 2061     		str	r0, [r4, #16]
 176:Ourwares/SerialTaskSend.c **** 	ptmp1->phuart  = p;
 234              		.loc 1 176 0
 235 0056 00EB8501 		add	r1, r0, r5, lsl #2
 236 005a A160     		str	r1, [r4, #8]
 177:Ourwares/SerialTaskSend.c **** 	ptmp1->dmaflag = dmaflag;
 237              		.loc 1 177 0
 238 005c 6761     		str	r7, [r4, #20]
 178:Ourwares/SerialTaskSend.c **** taskEXIT_CRITICAL();
 239              		.loc 1 178 0
 240 005e 2676     		strb	r6, [r4, #24]
 179:Ourwares/SerialTaskSend.c **** 	return 0;
 241              		.loc 1 179 0
 242 0060 FFF7FEFF 		bl	vPortExitCritical
 243              	.LVL24:
 180:Ourwares/SerialTaskSend.c **** }
 244              		.loc 1 180 0
 245 0064 0020     		movs	r0, #0
 181:Ourwares/SerialTaskSend.c **** 
 246              		.loc 1 181 0
 247 0066 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 248              	.LVL25:
 249              	.L23:
 250              		.align	2
 251              	.L22:
 252 0068 00000000 		.word	.LANCHOR0
 253              		.cfi_endproc
 254              	.LFE292:
 256              		.section	.text.xSerialTaskSendCreate,"ax",%progbits
 257              		.align	2
 258              		.global	xSerialTaskSendCreate
 259              		.thumb
 260              		.thumb_func
 262              	xSerialTaskSendCreate:
 263              	.LFB294:
 229:Ourwares/SerialTaskSend.c **** 			}
 230:Ourwares/SerialTaskSend.c **** 		}
 231:Ourwares/SerialTaskSend.c **** 	}
ARM GAS  /tmp/ccDiUcPk.s 			page 10


 232:Ourwares/SerialTaskSend.c **** }
 233:Ourwares/SerialTaskSend.c **** /* *************************************************************************
 234:Ourwares/SerialTaskSend.c ****  * osThreadId xSerialTaskSendCreate(uint32_t taskpriority);
 235:Ourwares/SerialTaskSend.c ****  * @brief	: Create task; task handle created is global for all to enjoy!
 236:Ourwares/SerialTaskSend.c ****  * @param	: taskpriority = Task priority (just as it says!)
 237:Ourwares/SerialTaskSend.c ****  * @return	: SerialTaskSendHandle
 238:Ourwares/SerialTaskSend.c ****  * *************************************************************************/
 239:Ourwares/SerialTaskSend.c **** osThreadId xSerialTaskSendCreate(uint32_t taskpriority)
 240:Ourwares/SerialTaskSend.c **** {
 264              		.loc 1 240 0
 265              		.cfi_startproc
 266              		@ args = 0, pretend = 0, frame = 0
 267              		@ frame_needed = 0, uses_anonymous_args = 0
 268              	.LVL26:
 269 0000 00B5     		push	{lr}
 270              	.LCFI3:
 271              		.cfi_def_cfa_offset 4
 272              		.cfi_offset 14, -4
 273 0002 83B0     		sub	sp, sp, #12
 274              	.LCFI4:
 275              		.cfi_def_cfa_offset 16
 241:Ourwares/SerialTaskSend.c **** /*
 242:Ourwares/SerialTaskSend.c **** BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
 243:Ourwares/SerialTaskSend.c **** const char * const pcName,
 244:Ourwares/SerialTaskSend.c **** unsigned short usStackDepth,
 245:Ourwares/SerialTaskSend.c **** void *pvParameters,
 246:Ourwares/SerialTaskSend.c **** UBaseType_t uxPriority,
 247:Ourwares/SerialTaskSend.c **** TaskHandle_t *pxCreatedTask );
 248:Ourwares/SerialTaskSend.c **** */
 249:Ourwares/SerialTaskSend.c **** 	BaseType_t ret = xTaskCreate(StartSerialTaskSend, "SerialTaskSend",\
 276              		.loc 1 249 0
 277 0004 0E4B     		ldr	r3, .L29
 278 0006 0193     		str	r3, [sp, #4]
 279 0008 0090     		str	r0, [sp]
 280 000a 0023     		movs	r3, #0
 281 000c 4FF48072 		mov	r2, #256
 282 0010 0C49     		ldr	r1, .L29+4
 283 0012 0D48     		ldr	r0, .L29+8
 284              	.LVL27:
 285 0014 FFF7FEFF 		bl	xTaskCreate
 286              	.LVL28:
 250:Ourwares/SerialTaskSend.c ****      256, NULL, taskpriority,\
 251:Ourwares/SerialTaskSend.c ****      &SerialTaskHandle);
 252:Ourwares/SerialTaskSend.c **** 	if (ret != pdPASS) return NULL;
 287              		.loc 1 252 0
 288 0018 0128     		cmp	r0, #1
 289 001a 0AD1     		bne	.L26
 253:Ourwares/SerialTaskSend.c **** 
 254:Ourwares/SerialTaskSend.c **** 	SerialTaskSendQHandle = xQueueCreate(QUEUESIZE, sizeof(struct SERIALSENDTASKBCB) );
 290              		.loc 1 254 0
 291 001c 0022     		movs	r2, #0
 292 001e 1421     		movs	r1, #20
 293 0020 1020     		movs	r0, #16
 294              	.LVL29:
 295 0022 FFF7FEFF 		bl	xQueueGenericCreate
 296              	.LVL30:
 297 0026 094B     		ldr	r3, .L29+12
ARM GAS  /tmp/ccDiUcPk.s 			page 11


 298 0028 1860     		str	r0, [r3]
 255:Ourwares/SerialTaskSend.c **** 	if (SerialTaskSendQHandle == NULL) return NULL;
 299              		.loc 1 255 0
 300 002a 20B1     		cbz	r0, .L27
 256:Ourwares/SerialTaskSend.c **** 	return SerialTaskHandle;
 301              		.loc 1 256 0
 302 002c 044B     		ldr	r3, .L29
 303 002e 1868     		ldr	r0, [r3]
 304 0030 02E0     		b	.L25
 305              	.LVL31:
 306              	.L26:
 252:Ourwares/SerialTaskSend.c **** 
 307              		.loc 1 252 0
 308 0032 0020     		movs	r0, #0
 309              	.LVL32:
 310 0034 00E0     		b	.L25
 311              	.L27:
 255:Ourwares/SerialTaskSend.c **** 	if (SerialTaskSendQHandle == NULL) return NULL;
 312              		.loc 1 255 0
 313 0036 0020     		movs	r0, #0
 314              	.L25:
 257:Ourwares/SerialTaskSend.c **** }
 315              		.loc 1 257 0
 316 0038 03B0     		add	sp, sp, #12
 317              	.LCFI5:
 318              		.cfi_def_cfa_offset 4
 319              		@ sp needed
 320 003a 5DF804FB 		ldr	pc, [sp], #4
 321              	.L30:
 322 003e 00BF     		.align	2
 323              	.L29:
 324 0040 00000000 		.word	.LANCHOR1
 325 0044 00000000 		.word	.LC0
 326 0048 00000000 		.word	StartSerialTaskSend
 327 004c 00000000 		.word	SerialTaskSendQHandle
 328              		.cfi_endproc
 329              	.LFE294:
 331              		.section	.text.HAL_UART_TxCpltCallback,"ax",%progbits
 332              		.align	2
 333              		.global	HAL_UART_TxCpltCallback
 334              		.thumb
 335              		.thumb_func
 337              	HAL_UART_TxCpltCallback:
 338              	.LFB295:
 258:Ourwares/SerialTaskSend.c **** /* #######################################################################
 259:Ourwares/SerialTaskSend.c ****    UART interrupt callback: file|size has been sent
 260:Ourwares/SerialTaskSend.c ****    ####################################################################### */
 261:Ourwares/SerialTaskSend.c **** void HAL_UART_TxCpltCallback(UART_HandleTypeDef *phuart)
 262:Ourwares/SerialTaskSend.c **** {
 339              		.loc 1 262 0
 340              		.cfi_startproc
 341              		@ args = 0, pretend = 0, frame = 8
 342              		@ frame_needed = 0, uses_anonymous_args = 0
 343              	.LVL33:
 344 0000 10B5     		push	{r4, lr}
 345              	.LCFI6:
 346              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccDiUcPk.s 			page 12


 347              		.cfi_offset 4, -8
 348              		.cfi_offset 14, -4
 349 0002 82B0     		sub	sp, sp, #8
 350              	.LCFI7:
 351              		.cfi_def_cfa_offset 16
 263:Ourwares/SerialTaskSend.c **** 	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 352              		.loc 1 263 0
 353 0004 0023     		movs	r3, #0
 354 0006 0193     		str	r3, [sp, #4]
 264:Ourwares/SerialTaskSend.c **** 
 265:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB* pbcb; // Buffer control block ptr
 266:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* ptmp1;	// Linked list of usarts
 267:Ourwares/SerialTaskSend.c **** 
 268:Ourwares/SerialTaskSend.c **** 	/* Find bcb circular buffer for this uart */
 269:Ourwares/SerialTaskSend.c **** 	ptmp1 = pbhd; // Polnt to first on list
 355              		.loc 1 269 0
 356 0008 194B     		ldr	r3, .L39
 357 000a 1C68     		ldr	r4, [r3]
 358              	.LVL34:
 270:Ourwares/SerialTaskSend.c **** 	while (ptmp1->phuart != phuart) 
 359              		.loc 1 270 0
 360 000c 00E0     		b	.L32
 361              	.L33:
 271:Ourwares/SerialTaskSend.c **** 	{
 272:Ourwares/SerialTaskSend.c **** 		ptmp1 = ptmp1->pnext; // Step to next uart
 362              		.loc 1 272 0
 363 000e 2468     		ldr	r4, [r4]
 364              	.LVL35:
 365              	.L32:
 270:Ourwares/SerialTaskSend.c **** 	while (ptmp1->phuart != phuart) 
 366              		.loc 1 270 0
 367 0010 6369     		ldr	r3, [r4, #20]
 368 0012 8342     		cmp	r3, r0
 369 0014 FBD1     		bne	.L33
 273:Ourwares/SerialTaskSend.c **** 	}
 274:Ourwares/SerialTaskSend.c **** 
 275:Ourwares/SerialTaskSend.c **** 	/* Pointer to buffer control block for next buffer to send. */
 276:Ourwares/SerialTaskSend.c **** 	pbcb = *ptmp1->ptake;
 370              		.loc 1 276 0
 371 0016 2369     		ldr	r3, [r4, #16]
 372 0018 1B68     		ldr	r3, [r3]
 373              	.LVL36:
 277:Ourwares/SerialTaskSend.c **** 
 278:Ourwares/SerialTaskSend.c ****    /* Release buffer just sent to it can be reused. */
 279:Ourwares/SerialTaskSend.c **** 	xSemaphoreGiveFromISR( pbcb->semaphore, &xHigherPriorityTaskWoken );
 374              		.loc 1 279 0
 375 001a 01A9     		add	r1, sp, #4
 376 001c 9868     		ldr	r0, [r3, #8]
 377              	.LVL37:
 378 001e FFF7FEFF 		bl	xQueueGiveFromISR
 379              	.LVL38:
 280:Ourwares/SerialTaskSend.c **** 
 281:Ourwares/SerialTaskSend.c **** 	/* Advance 'take' pointer of circular bcb buffer. */
 282:Ourwares/SerialTaskSend.c **** 	ptmp1->ptake += 1;	// Advance ptr with wraparound
 380              		.loc 1 282 0
 381 0022 2369     		ldr	r3, [r4, #16]
 382 0024 0433     		adds	r3, r3, #4
ARM GAS  /tmp/ccDiUcPk.s 			page 13


 383 0026 2361     		str	r3, [r4, #16]
 283:Ourwares/SerialTaskSend.c **** 	if (ptmp1->ptake == ptmp1->pend) ptmp1->ptake = ptmp1->pbegin;	
 384              		.loc 1 283 0
 385 0028 A268     		ldr	r2, [r4, #8]
 386 002a 9342     		cmp	r3, r2
 387 002c 01D1     		bne	.L34
 388              		.loc 1 283 0 is_stmt 0 discriminator 1
 389 002e 6368     		ldr	r3, [r4, #4]
 390 0030 2361     		str	r3, [r4, #16]
 391              	.L34:
 284:Ourwares/SerialTaskSend.c **** 
 285:Ourwares/SerialTaskSend.c **** 	/* If more bcb remain in the buffer start the next sending. */
 286:Ourwares/SerialTaskSend.c **** 	if (ptmp1->ptake != ptmp1->padd)
 392              		.loc 1 286 0 is_stmt 1
 393 0032 2369     		ldr	r3, [r4, #16]
 394 0034 E268     		ldr	r2, [r4, #12]
 395 0036 9342     		cmp	r3, r2
 396 0038 0ED0     		beq	.L35
 287:Ourwares/SerialTaskSend.c **** 	{
 288:Ourwares/SerialTaskSend.c **** 		pbcb = *ptmp1->ptake;
 397              		.loc 1 288 0
 398 003a 1B68     		ldr	r3, [r3]
 399              	.LVL39:
 289:Ourwares/SerialTaskSend.c **** 		if (ptmp1->dmaflag == 0)
 400              		.loc 1 289 0
 401 003c 94F91820 		ldrsb	r2, [r4, #24]
 402 0040 2AB9     		cbnz	r2, .L36
 290:Ourwares/SerialTaskSend.c **** 			HAL_UART_Transmit_IT (pbcb->phuart,pbcb->pbuf,pbcb->size);
 403              		.loc 1 290 0
 404 0042 1A8A     		ldrh	r2, [r3, #16]
 405 0044 D968     		ldr	r1, [r3, #12]
 406 0046 1868     		ldr	r0, [r3]
 407 0048 FFF7FEFF 		bl	HAL_UART_Transmit_IT
 408              	.LVL40:
 409 004c 04E0     		b	.L35
 410              	.LVL41:
 411              	.L36:
 291:Ourwares/SerialTaskSend.c **** 		else
 292:Ourwares/SerialTaskSend.c **** 			HAL_UART_Transmit_DMA(pbcb->phuart,pbcb->pbuf,pbcb->size);
 412              		.loc 1 292 0
 413 004e 1A8A     		ldrh	r2, [r3, #16]
 414 0050 D968     		ldr	r1, [r3, #12]
 415 0052 1868     		ldr	r0, [r3]
 416 0054 FFF7FEFF 		bl	HAL_UART_Transmit_DMA
 417              	.LVL42:
 418              	.L35:
 293:Ourwares/SerialTaskSend.c **** 	}
 294:Ourwares/SerialTaskSend.c **** 	portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 419              		.loc 1 294 0
 420 0058 019B     		ldr	r3, [sp, #4]
 421 005a 3BB1     		cbz	r3, .L31
 422              		.loc 1 294 0 is_stmt 0 discriminator 1
 423 005c 4FF08052 		mov	r2, #268435456
 424 0060 044B     		ldr	r3, .L39+4
 425 0062 1A60     		str	r2, [r3]
 426              		.syntax unified
 427              	@ 294 "Ourwares/SerialTaskSend.c" 1
ARM GAS  /tmp/ccDiUcPk.s 			page 14


 428 0064 BFF34F8F 		dsb
 429              	@ 0 "" 2
 430              	@ 294 "Ourwares/SerialTaskSend.c" 1
 431 0068 BFF36F8F 		isb
 432              	@ 0 "" 2
 433              		.thumb
 434              		.syntax unified
 435              	.L31:
 295:Ourwares/SerialTaskSend.c **** 	return;
 296:Ourwares/SerialTaskSend.c **** }
 436              		.loc 1 296 0 is_stmt 1
 437 006c 02B0     		add	sp, sp, #8
 438              	.LCFI8:
 439              		.cfi_def_cfa_offset 8
 440              		@ sp needed
 441 006e 10BD     		pop	{r4, pc}
 442              	.LVL43:
 443              	.L40:
 444              		.align	2
 445              	.L39:
 446 0070 00000000 		.word	.LANCHOR0
 447 0074 04ED00E0 		.word	-536810236
 448              		.cfi_endproc
 449              	.LFE295:
 451              		.section	.text.vSerialTaskSendQueueBuf,"ax",%progbits
 452              		.align	2
 453              		.global	vSerialTaskSendQueueBuf
 454              		.thumb
 455              		.thumb_func
 457              	vSerialTaskSendQueueBuf:
 458              	.LFB296:
 297:Ourwares/SerialTaskSend.c **** 
 298:Ourwares/SerialTaskSend.c **** /* *************************************************************************
 299:Ourwares/SerialTaskSend.c ****  * void vSerialTaskSendQueueBuf(struct SERIALSENDTASKBCB** ppbcb);
 300:Ourwares/SerialTaskSend.c ****  *	@brief	: Load buffer control block onto queue for sending
 301:Ourwares/SerialTaskSend.c ****  * @param	: ppbcb = Pointer to pointer to Buffer Control Block
 302:Ourwares/SerialTaskSend.c ****  * *************************************************************************/
 303:Ourwares/SerialTaskSend.c **** void vSerialTaskSendQueueBuf(struct SERIALSENDTASKBCB** ppbcb)
 304:Ourwares/SerialTaskSend.c **** {
 459              		.loc 1 304 0
 460              		.cfi_startproc
 461              		@ args = 0, pretend = 0, frame = 0
 462              		@ frame_needed = 0, uses_anonymous_args = 0
 463              	.LVL44:
 464 0000 38B5     		push	{r3, r4, r5, lr}
 465              	.LCFI9:
 466              		.cfi_def_cfa_offset 16
 467              		.cfi_offset 3, -16
 468              		.cfi_offset 4, -12
 469              		.cfi_offset 5, -8
 470              		.cfi_offset 14, -4
 471 0002 0546     		mov	r5, r0
 472              	.LVL45:
 473              	.L43:
 305:Ourwares/SerialTaskSend.c **** 	uint32_t qret;
 306:Ourwares/SerialTaskSend.c **** 
 307:Ourwares/SerialTaskSend.c **** 	do 
ARM GAS  /tmp/ccDiUcPk.s 			page 15


 308:Ourwares/SerialTaskSend.c **** 	{
 309:Ourwares/SerialTaskSend.c **** 		qret=xQueueSendToBack(SerialTaskSendQHandle, ppbcb, portMAX_DELAY);
 474              		.loc 1 309 0
 475 0004 0023     		movs	r3, #0
 476 0006 4FF0FF32 		mov	r2, #-1
 477 000a 2946     		mov	r1, r5
 478 000c 0548     		ldr	r0, .L45
 479 000e 0068     		ldr	r0, [r0]
 480 0010 FFF7FEFF 		bl	xQueueGenericSend
 481              	.LVL46:
 310:Ourwares/SerialTaskSend.c **** 		if (qret == errQUEUE_FULL) osDelay(1); // Delay, don't spin.
 482              		.loc 1 310 0
 483 0014 0446     		mov	r4, r0
 484 0016 10B9     		cbnz	r0, .L42
 485              		.loc 1 310 0 is_stmt 0 discriminator 1
 486 0018 0120     		movs	r0, #1
 487              	.LVL47:
 488 001a FFF7FEFF 		bl	osDelay
 489              	.LVL48:
 490              	.L42:
 311:Ourwares/SerialTaskSend.c **** 
 312:Ourwares/SerialTaskSend.c **** 	} while(qret == errQUEUE_FULL);
 491              		.loc 1 312 0 is_stmt 1
 492 001e 002C     		cmp	r4, #0
 493 0020 F0D0     		beq	.L43
 313:Ourwares/SerialTaskSend.c **** 	return;
 314:Ourwares/SerialTaskSend.c **** }
 494              		.loc 1 314 0
 495 0022 38BD     		pop	{r3, r4, r5, pc}
 496              	.LVL49:
 497              	.L46:
 498              		.align	2
 499              	.L45:
 500 0024 00000000 		.word	SerialTaskSendQHandle
 501              		.cfi_endproc
 502              	.LFE296:
 504              		.global	pbhd
 505              		.comm	SerialTaskSendQHandle,4,4
 506              		.global	SerialTaskHandle
 507              		.section	.bss.pbhd,"aw",%nobits
 508              		.align	2
 509              		.set	.LANCHOR0,. + 0
 512              	pbhd:
 513 0000 00000000 		.space	4
 514              		.section	.bss.SerialTaskHandle,"aw",%nobits
 515              		.align	2
 516              		.set	.LANCHOR1,. + 0
 519              	SerialTaskHandle:
 520 0000 00000000 		.space	4
 521              		.section	.rodata.str1.4,"aMS",%progbits,1
 522              		.align	2
 523              	.LC0:
 524 0000 53657269 		.ascii	"SerialTaskSend\000"
 524      616C5461 
 524      736B5365 
 524      6E6400
 525              		.text
ARM GAS  /tmp/ccDiUcPk.s 			page 16


 526              	.Letext0:
 527              		.file 2 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/machine/_default_t
 528              		.file 3 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/_stdint.h"
 529              		.file 4 "Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 530              		.file 5 "Middlewares/Third_Party/FreeRTOS/Source/include/queue.h"
 531              		.file 6 "Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2/cmsis_os2.h"
 532              		.file 7 "Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2/cmsis_os.h"
 533              		.file 8 "Drivers/CMSIS/Device/ST/STM32L4xx/Include/stm32l431xx.h"
 534              		.file 9 "Drivers/STM32L4xx_HAL_Driver/Inc/stm32l4xx_hal_def.h"
 535              		.file 10 "Drivers/STM32L4xx_HAL_Driver/Inc/stm32l4xx_hal_dma.h"
 536              		.file 11 "Drivers/STM32L4xx_HAL_Driver/Inc/stm32l4xx_hal_uart.h"
 537              		.file 12 "Middlewares/Third_Party/FreeRTOS/Source/include/semphr.h"
 538              		.file 13 "Ourwares/SerialTaskSend.h"
 539              		.file 14 "Drivers/CMSIS/Include/cmsis_gcc.h"
 540              		.file 15 "Drivers/CMSIS/Include/core_cm4.h"
 541              		.file 16 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/malloc.h"
 542              		.file 17 "Middlewares/Third_Party/FreeRTOS/Source/include/task.h"
ARM GAS  /tmp/ccDiUcPk.s 			page 17


DEFINED SYMBOLS
                            *ABS*:00000000 SerialTaskSend.c
     /tmp/ccDiUcPk.s:22     .text.StartSerialTaskSend:00000000 $t
     /tmp/ccDiUcPk.s:27     .text.StartSerialTaskSend:00000000 StartSerialTaskSend
     /tmp/ccDiUcPk.s:139    .text.StartSerialTaskSend:00000084 $d
                            *COM*:00000004 SerialTaskSendQHandle
     /tmp/ccDiUcPk.s:145    .text.xSerialTaskSendAdd:00000000 $t
     /tmp/ccDiUcPk.s:150    .text.xSerialTaskSendAdd:00000000 xSerialTaskSendAdd
     /tmp/ccDiUcPk.s:252    .text.xSerialTaskSendAdd:00000068 $d
     /tmp/ccDiUcPk.s:257    .text.xSerialTaskSendCreate:00000000 $t
     /tmp/ccDiUcPk.s:262    .text.xSerialTaskSendCreate:00000000 xSerialTaskSendCreate
     /tmp/ccDiUcPk.s:324    .text.xSerialTaskSendCreate:00000040 $d
     /tmp/ccDiUcPk.s:332    .text.HAL_UART_TxCpltCallback:00000000 $t
     /tmp/ccDiUcPk.s:337    .text.HAL_UART_TxCpltCallback:00000000 HAL_UART_TxCpltCallback
     /tmp/ccDiUcPk.s:446    .text.HAL_UART_TxCpltCallback:00000070 $d
     /tmp/ccDiUcPk.s:452    .text.vSerialTaskSendQueueBuf:00000000 $t
     /tmp/ccDiUcPk.s:457    .text.vSerialTaskSendQueueBuf:00000000 vSerialTaskSendQueueBuf
     /tmp/ccDiUcPk.s:500    .text.vSerialTaskSendQueueBuf:00000024 $d
     /tmp/ccDiUcPk.s:512    .bss.pbhd:00000000 pbhd
     /tmp/ccDiUcPk.s:519    .bss.SerialTaskHandle:00000000 SerialTaskHandle
     /tmp/ccDiUcPk.s:508    .bss.pbhd:00000000 $d
     /tmp/ccDiUcPk.s:515    .bss.SerialTaskHandle:00000000 $d
     /tmp/ccDiUcPk.s:522    .rodata.str1.4:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueReceive
xQueueGenericSend
HAL_UART_Transmit_IT
HAL_UART_Transmit_DMA
vPortEnterCritical
calloc
vPortExitCritical
xTaskCreate
xQueueGenericCreate
xQueueGiveFromISR
osDelay
